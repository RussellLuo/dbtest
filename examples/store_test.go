// Code generated by dbtest; DO NOT EDIT.
// github.com/RussellLuo/dbtest

package store_test

import (
	"fmt"
	"os"
	"testing"

	"github.com/protogodev/dbtest/builtin"
	store "github.com/protogodev/dbtest/examples"
	"github.com/protogodev/dbtest/spec"
)

var (
	testee *builtin.Testee
	sut    store.Store
)

func TestMain(m *testing.M) {
	t, err := store.NewTestee("root:root@tcp(127.0.0.1:3306)/test")
	if err != nil {
		fmt.Printf("err: %v\n", err)
		os.Exit(1)
	}

	testee = t.Complete()
	if err := testee.Validate(); err != nil {
		fmt.Printf("err: %v\n", err)
		os.Exit(1)
	}
	sut = testee.SUT.(store.Store)

	// os.Exit() does not respect deferred functions
	code := m.Run()

	_ = testee.DB.Close()
	os.Exit(code)
}

func TestCreateUser(t *testing.T) {
	f := builtin.NewFixture(t, testee.DB, map[string]spec.Rows{
		"user": {
			{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
		},
	})
	f.SetUp()
	defer f.TearDown()

	// in contains all the input parameters (except ctx) of CreateUser.
	type in struct {
		User *store.User `dbtest:"user"`
	}

	// out contains all the output parameters of CreateUser.
	type out struct {
		Err error `dbtest:"err"`
	}

	tests := []struct {
		name     string
		in       map[string]interface{}
		wantOut  map[string]interface{}
		wantData []spec.DataAssertion
	}{
		{
			name:    "new user",
			in:      map[string]interface{}{"user": map[interface{}]interface{}{"age": 12, "birth": "2021-08-12T00:00:00Z", "name": "bar", "sex": "f"}},
			wantOut: map[string]interface{}{"err": ""},
			wantData: []spec.DataAssertion{
				{
					Query: "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{
						{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
						{"age": 12, "birth": "2021-08-12T00:00:00Z", "name": "bar", "sex": "f"},
					},
				},
			},
		},
		{
			name:    "duplicate user",
			in:      map[string]interface{}{"user": map[interface{}]interface{}{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"}},
			wantOut: map[string]interface{}{"err": "Error 1062: Duplicate entry 'foo' for key 'user.idx_name'"},
			wantData: []spec.DataAssertion{
				{
					Query: "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{
						{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var in in
			if err := testee.Codec.Decode(tt.in, &in); err != nil {
				t.Errorf("err when decoding In: %v", err)
			}

			var gotOut out
			gotOut.Err = sut.CreateUser(in.User)

			encodedOut, err := testee.Codec.Encode(gotOut)
			if err != nil {
				t.Errorf("err when encoding Out: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedOut) != fmt.Sprintf("%+v", tt.wantOut) {
				t.Errorf("Out: Got (%+v) != Want (%+v)", encodedOut, tt.wantOut)
			}

			for _, want := range tt.wantData {
				gotResult := f.Query(want.Query)
				if !gotResult.Equal(want.Result) {
					t.Errorf("Result: Got (%#v) != Want (%#v)", gotResult, want.Result)
				}
			}

			if len(tt.wantData) > 0 {
				// This is an unsafe test, reset the fixture.
				f.Reset()
			}
		})
	}
}

func TestGetUser(t *testing.T) {
	f := builtin.NewFixture(t, testee.DB, map[string]spec.Rows{
		"user": {
			{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
		},
	})
	f.SetUp()
	defer f.TearDown()

	// in contains all the input parameters (except ctx) of GetUser.
	type in struct {
		Name string `dbtest:"name"`
	}

	// out contains all the output parameters of GetUser.
	type out struct {
		User *store.User `dbtest:"user"`
		Err  error       `dbtest:"err"`
	}

	tests := []struct {
		name     string
		in       map[string]interface{}
		wantOut  map[string]interface{}
		wantData []spec.DataAssertion
	}{
		{
			name:     "ok",
			in:       map[string]interface{}{"name": "foo"},
			wantOut:  map[string]interface{}{"err": "", "user": map[interface{}]interface{}{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"}},
			wantData: []spec.DataAssertion{},
		},
		{
			name:     "not found",
			in:       map[string]interface{}{"name": "bar"},
			wantOut:  map[string]interface{}{"err": "", "user": interface{}(nil)},
			wantData: []spec.DataAssertion{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var in in
			if err := testee.Codec.Decode(tt.in, &in); err != nil {
				t.Errorf("err when decoding In: %v", err)
			}

			var gotOut out
			gotOut.User, gotOut.Err = sut.GetUser(in.Name)

			encodedOut, err := testee.Codec.Encode(gotOut)
			if err != nil {
				t.Errorf("err when encoding Out: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedOut) != fmt.Sprintf("%+v", tt.wantOut) {
				t.Errorf("Out: Got (%+v) != Want (%+v)", encodedOut, tt.wantOut)
			}

			for _, want := range tt.wantData {
				gotResult := f.Query(want.Query)
				if !gotResult.Equal(want.Result) {
					t.Errorf("Result: Got (%#v) != Want (%#v)", gotResult, want.Result)
				}
			}

			if len(tt.wantData) > 0 {
				// This is an unsafe test, reset the fixture.
				f.Reset()
			}
		})
	}
}

func TestUpdateUser(t *testing.T) {
	f := builtin.NewFixture(t, testee.DB, map[string]spec.Rows{
		"user": {
			{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
		},
	})
	f.SetUp()
	defer f.TearDown()

	// in contains all the input parameters (except ctx) of UpdateUser.
	type in struct {
		Name string      `dbtest:"name"`
		User *store.User `dbtest:"user"`
	}

	// out contains all the output parameters of UpdateUser.
	type out struct {
		Err error `dbtest:"err"`
	}

	tests := []struct {
		name     string
		in       map[string]interface{}
		wantOut  map[string]interface{}
		wantData []spec.DataAssertion
	}{
		{
			name:    "ok",
			in:      map[string]interface{}{"name": "foo", "user": map[interface{}]interface{}{"age": 11, "birth": "2021-08-11T00:00:00Z", "sex": "m"}},
			wantOut: map[string]interface{}{"err": ""},
			wantData: []spec.DataAssertion{
				{
					Query: "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{
						{"age": 11, "birth": "2021-08-11T00:00:00Z", "name": "foo", "sex": "m"},
					},
				},
			},
		},
		{
			name:    "not found",
			in:      map[string]interface{}{"name": "bar", "user": map[interface{}]interface{}{"age": 11, "birth": "2021-08-11T00:00:00Z", "sex": "m"}},
			wantOut: map[string]interface{}{"err": ""},
			wantData: []spec.DataAssertion{
				{
					Query: "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{
						{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var in in
			if err := testee.Codec.Decode(tt.in, &in); err != nil {
				t.Errorf("err when decoding In: %v", err)
			}

			var gotOut out
			gotOut.Err = sut.UpdateUser(in.Name, in.User)

			encodedOut, err := testee.Codec.Encode(gotOut)
			if err != nil {
				t.Errorf("err when encoding Out: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedOut) != fmt.Sprintf("%+v", tt.wantOut) {
				t.Errorf("Out: Got (%+v) != Want (%+v)", encodedOut, tt.wantOut)
			}

			for _, want := range tt.wantData {
				gotResult := f.Query(want.Query)
				if !gotResult.Equal(want.Result) {
					t.Errorf("Result: Got (%#v) != Want (%#v)", gotResult, want.Result)
				}
			}

			if len(tt.wantData) > 0 {
				// This is an unsafe test, reset the fixture.
				f.Reset()
			}
		})
	}
}

func TestDeleteUser(t *testing.T) {
	f := builtin.NewFixture(t, testee.DB, map[string]spec.Rows{
		"user": {
			{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
		},
	})
	f.SetUp()
	defer f.TearDown()

	// in contains all the input parameters (except ctx) of DeleteUser.
	type in struct {
		Name string `dbtest:"name"`
	}

	// out contains all the output parameters of DeleteUser.
	type out struct {
		Err error `dbtest:"err"`
	}

	tests := []struct {
		name     string
		in       map[string]interface{}
		wantOut  map[string]interface{}
		wantData []spec.DataAssertion
	}{
		{
			name:    "ok",
			in:      map[string]interface{}{"name": "foo"},
			wantOut: map[string]interface{}{"err": ""},
			wantData: []spec.DataAssertion{
				{
					Query:  "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{},
				},
			},
		},
		{
			name:    "not found",
			in:      map[string]interface{}{"name": "bar"},
			wantOut: map[string]interface{}{"err": ""},
			wantData: []spec.DataAssertion{
				{
					Query: "SELECT name, sex, age, birth FROM user",
					Result: spec.Rows{
						{"age": 10, "birth": "2021-08-10T00:00:00Z", "name": "foo", "sex": "m"},
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var in in
			if err := testee.Codec.Decode(tt.in, &in); err != nil {
				t.Errorf("err when decoding In: %v", err)
			}

			var gotOut out
			gotOut.Err = sut.DeleteUser(in.Name)

			encodedOut, err := testee.Codec.Encode(gotOut)
			if err != nil {
				t.Errorf("err when encoding Out: %v", err)
			}

			// Using "%+v" instead of "%#v" as a workaround for https://github.com/go-yaml/yaml/issues/139.
			if fmt.Sprintf("%+v", encodedOut) != fmt.Sprintf("%+v", tt.wantOut) {
				t.Errorf("Out: Got (%+v) != Want (%+v)", encodedOut, tt.wantOut)
			}

			for _, want := range tt.wantData {
				gotResult := f.Query(want.Query)
				if !gotResult.Equal(want.Result) {
					t.Errorf("Result: Got (%#v) != Want (%#v)", gotResult, want.Result)
				}
			}

			if len(tt.wantData) > 0 {
				// This is an unsafe test, reset the fixture.
				f.Reset()
			}
		})
	}
}
